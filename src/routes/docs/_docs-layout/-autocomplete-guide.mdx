import { CodeBlock, CodePreviewTabs, InstallTabs } from '@/components/code-block'
import StandardExampleTsx from "@/components/examples/standard.tsx?raw";
import {StandardExample} from "@/components/examples/standard";

import DisabledItemTsx from "@/components/examples/disabled-item.tsx?raw";
import {DisabledItem} from "@/components/examples/disabled-item";

import DisabledInputTsx from "@/components/examples/disabled-input.tsx?raw";
import {DisabledInput} from "@/components/examples/disabled-input";

import ActionsTsx from "@/components/examples/actions.tsx?raw";
import {Actions} from "@/components/examples/actions";

import GroupsTsx from "@/components/examples/groups.tsx?raw";
import {GroupsExample} from "@/components/examples/groups";

import MultipleGroupsTsx from "@/components/examples/multiple-groups.tsx?raw";
import {MultipleGroupsExample} from "@/components/examples/multiple-groups";

import MultiselectTsx from "@/components/examples/multiselect.tsx?raw";
import {MultiselectExample} from "@/components/examples/multiselect";

import TabsTsx from "@/components/examples/tabs.tsx?raw";
import {TabsExample} from "@/components/examples/tabs";


# Autocomplete Guide

## Installation
Start by installing the Wispe package using your preferred package manager:
{/* 
```bash
npm install @wispe/autocomplete
```
```bash
yarn add @wispe/autocomplete
```
```bash
pnpm add @wispe/autocomplete
```
```bash
bun add @wispe/autocomplete
``` */}


{
<div className="space-y-3 pt-3">
<InstallTabs/>
</div>
}

## How It Works
The Wispe Autocomplete is built with a core hook that takes in all the information that it needs,
and exposes properties and methods that can be composed into a component that
suits your specific needs. This allows you to create a highly customizable autocomplete component
that can be tailored to your application's requirements.

Specially, you will generally input at least:

- `items` (Required): an array of items to filter through.
- `onFilterAsync`: an optional asynchronous function that filters the items based on the current input value.
- `itemToString`: a function that converts an item to a string for display purposes (not needed for primitive lists).

and you will get out at least:

- `getRootProps`: applies the necessary props to the root element of the autocomplete component.
- `getLabelProps`: applies the necessary props to the label element.
- `getInputProps`: applies the necessary props to the input element.
- `getListProps`: applies the necessary props to the list element.
- `getItemProps`: applies the necessary props to each item in the list.
- `getItemState`: gets the state of each item in the list, such as whether it is selected or focused.
- `getItems`: returns the filtered list of items based on the current input value.
- `isOpen`: indicates whether the autocomplete list is currently open.

For example:
```tsx
import { useAutoComplete } from "@wispe/wispe-react";

export interface User {
  id: number;
  name: string;
}

export const users: User[] = [
  { id: 1, name: "John Doe" },
  { id: 2, name: "Jane Smith" },
  { id: 3, name: "Bob Johnson" },
  { id: 4, name: "Alice Brown" },
  { id: 5, name: "Charlie Wilson" },
];

export function BasicAutocomplete() {
  const {
    getRootProps,
    getLabelProps,
    getInputProps,
    getListProps,
    getItemProps,
    getItemState,
    getItems,
    isOpen,
  } = useAutoComplete({
    items: users,
    onFilterAsync: async ({ searchTerm }) =>
      users.filter((u) =>
        u.name.toLowerCase().includes(searchTerm.toLowerCase())
      ),
    itemToString: (u) => u.name,
  });

  return (
    <>
      <label {...getLabelProps()}>Search users</label>
      <div {...getRootProps()}>
        <input {...getInputProps()} />

        {isOpen && (
          <ul {...getListProps()}>
            {getItems().map((user) => (
              <li key={user.id} {...getItemProps(user)}>
                <span>
                  {user.name} {getItemState(user).isSelected && <span>✓</span>}
                </span>
              </li>
            ))}
          </ul>
        )}
      </div>
    </>
  );
}
```

## Data
As with Tanstack Table, the data array that you pass to the autocomplete instance MUST have a "stable" reference in order to prevent bugs that cause infinite re-renders.

This will frequently mean `React.useState`, `React.useMemo`, or similar to ensure that both the data and columns table options have stable references.

```tsx
const fallbackData = []

export default function MyComponent() {
  //✅ GOOD: This will not cause an infinite loop of re-renders because `users` is a stable reference
  const users = useMemo(() => [
    // ...
  ], []);

  const {
    // ...
    isOpen,
  } = useAutoComplete({
    items: users,
    onFilterAsync: async ({ searchTerm }) =>
      users.filter((u) =>
        u.name.toLowerCase().includes(searchTerm.toLowerCase())
      ),
    itemToString: (u) => u.name,
  });

  //✅ GOOD: This will not cause an infinite loop of re-renders because `data` is a stable reference
  const [data, setData] = useState(() => [
    // ...
  ]);

  const {
    // ...
    isOpen,
  } = useAutoComplete({
    items: data,
    onFilterAsync: async ({ searchTerm }) =>
      data.filter((d) =>
        d.toLowerCase().includes(searchTerm.toLowerCase())
      ),
  });

  return <div>...</div>;
}
```

`React.useState` and `React.useMemo` are not the only ways to give your data a stable reference. You can also define your 
data outside of the component or use a 3rd party state management library like Redux, Zustand, or TanStack Query.

The main thing to avoid is defining the data array inside the same scope as the `useAutoComplete` call. That will 
cause the data array to be redefined on every render, which will cause an infinite loop of re-renders.
tsx

```tsx
export default function MyComponent() {
  //😵 BAD: This will cause an infinite loop of re-renders because `data` is redefined as a new array on every render!
  const data = [
    // ...
  ];

  const {
    // ...
    isOpen,
  } = useAutoComplete({
    items: data ?? [], //❌ Also bad because the fallback array is re-created on every render
    onFilterAsync: async ({ searchTerm }) =>
      data.filter((d) =>
        d.toLowerCase().includes(searchTerm.toLowerCase())
      ),
  });

  return <div>...</div>;
}
```

## Features

### Disabled Input
To disabled the input, you can pass a `disabled` property in the `state` object when calling the 
`useAutoComplete` hook. This will disable the input and prevent any interaction with it.

You can also use the `getIsDisabled` method to check if the input is disabled, which can 
be useful for conditionally rendering UI elements based on the disabled state.

<div className="pt-3">
  <CodePreviewTabs code={DisabledItemTsx} preview={<DisabledItem />} />
</div>

### Disabled Items
To disable specific items in the list, you can use the `isItemDisabled` option when calling the `useAutoComplete` hook.
This option takes a function that receives an item and returns a boolean indicating whether the item should be disabled.
This can be any condition you want, such as checking a property of the item or its value.


<div className="pt-3">
  <CodePreviewTabs code={DisabledInputTsx} preview={<DisabledInput />} />
</div>

### Actions
You can pass an `actions` object to the `useAutoComplete` hook to define custom actions that can be performed
from the listbox. This can be useful for adding custom functionality like opening a modal to add a complex item, 
or maybe adding a clear option.

An action is an object that contains a `label` to display in the listbox, a placement of `top` or `bottom` to 
determine where it should be rendered in the list, and an `onAction` callback that is called when the action is triggered.

<div className="pt-3">
  <CodePreviewTabs code={ActionsTsx} preview={<Actions />} />
</div>

### Groupings
You can use `state.grouping` to pass a list of groupings (`{ label: string, key: keyof T }[]`) to the `useAutoComplete` hook.
The `key` is the property of the item that you want to group by, and the `label` is the label to display for the group.

The `getGroupProps`, `getGroupLabelProps`, and `getItems` methods are used to retrieve the groups and their items to 
display in whatever way makes sense for you.


<div className="py-3">
  <CodePreviewTabs code={GroupsTsx} preview={<GroupsExample />} />
</div>

If you pass multiple groupings, you will see group types down the item hierarchy until you get to the actual items.

<div className="pt-3">
  <CodePreviewTabs code={MultipleGroupsTsx} preview={<MultipleGroupsExample />} />
</div>

### Multiselect
You can enable multi-select mode by passing a `mode` of `multiple` to the `useAutoComplete` hook. This will tell the autocomplete hook to
allow multiple items to be selected at once. The autocomplete is smart enough to then know that methods like `getSelectedItems` should return 
an array of the currently selected items now.

<div className="pt-3">
  <CodePreviewTabs code={MultiselectTsx} preview={<MultiselectExample />} />
</div>

### Tabs
Tabs can be used to filter items in the list based on a given callback. To use tabs, you can pass a `tabs` array 
to the `useAutoComplete` hook, which contains objects with a `label`, a `filter` function, and a `key`. The filter
takes in an item of whatever type you are using, and returns a boolean indicating whether the item should 
be included in the tab.

Note that as with the autocomplete items, the tabs should have some kind of stable data source as described above.

<div className="pt-3">
  <CodePreviewTabs code={TabsTsx} preview={<TabsExample />} />
</div>